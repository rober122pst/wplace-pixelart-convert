<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para o corpo e contêiner */
        body {
            font-family: 'Inter', sans-serif; /* Fonte Inter para uma aparência moderna */
            background-color: #f0f0f0; /* Fundo cinza claro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Altura mínima para ocupar a tela inteira */
            padding: 20px; /* Preenchimento para evitar que o conteúdo toque as bordas */
        }
        .container {
            background-color: #ffffff; /* Fundo branco para o contêiner principal */
            border-radius: 12px; /* Cantos arredondados */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Sombra suave */
            padding: 30px; /* Preenchimento interno */
            max-width: 1200px; /* Largura máxima para desktops */
            width: 100%; /* Ocupa toda a largura disponível */
        }
        /* Estilos para os elementos canvas */
        canvas {
            border: 1px solid #e0e0e0; /* Borda sutil */
            border-radius: 8px; /* Cantos arredondados */
            background-color: #f9f9f9; /* Fundo levemente cinza para o canvas */
            width: 100%; /* Torna o canvas fluido, ocupando a largura total do pai */
            height: auto; /* Mantém a proporção da imagem */
        }
        #pixelArtCanvas {
            image-rendering: optimizeSpeed;             /* Para Chrome, Edge */
            image-rendering: -moz-crisp-edges;          /* Para Firefox */
            image-rendering: -webkit-optimize-contrast; /* Para Safari (legado) */
            image-rendering: pixelated;                 /* Padrão moderno */
            image-rendering: crisp-edges;               /* Outros navegadores (legado) */
        }
        /* Estilos para o thumb do slider de range */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4F46E5; /* Cor do thumb (índigo) */
            cursor: pointer;
            border-radius: 50%; /* Formato circular */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Sombra para o thumb */
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4F46E5; /* Cor do thumb (índigo) */
            cursor: pointer;
            border-radius: 50%; /* Formato circular */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Sombra para o thumb */
        }

        /* Estilo do Tooltip para a cor no hover */
        #colorTooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none; /* Garante que o tooltip não interfere com eventos do mouse */
            z-index: 10;
            white-space: nowrap;
            transform: translate(-50%, -100%);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container grid grid-cols-1 lg:grid-cols-2 gap-8">
        <!-- Seção de Controles e Entrada -->
        <div class="flex flex-col space-y-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-4 text-center lg:text-left">Transformar Foto em Pixel Art</h1>

            <!-- Carregar Imagem -->
            <div class="flex flex-col space-y-4">
                <label for="imageUpload" class="block text-lg font-medium text-gray-700">Carregar Imagem:</label>
                <input type="file" id="imageUpload" accept="image/*" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
            </div>

            <!-- Tamanho do Pixel (Slider) -->
            <div class="flex flex-col space-y-4">
                <label for="pixelSize" class="block text-lg font-medium text-gray-700">Tamanho do Pixel: <span id="pixelSizeValue" class="font-semibold text-indigo-600">10</span>px</label>
                <input type="range" id="pixelSize" min="1" max="50" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            </div>

            <!-- Botão Converter -->
            <button id="convertBtn" class="bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 ease-in-out transform hover:scale-105">
                Converter para Pixel Art
            </button>

            <!-- Indicador de Carregamento -->
            <div id="loadingIndicator" class="hidden text-center text-indigo-600 font-medium">
                Processando...
            </div>

            <!-- Botão Baixar Pixel Art -->
            <button id="downloadBtn" class="bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 transition duration-300 ease-in-out transform hover:scale-105 mt-4" disabled>
                Baixar Pixel Art
            </button>

            <!-- Estatísticas da Pixel Art -->
            <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                <h2 class="text-xl font-bold text-gray-800 mb-4">Estatísticas da Pixel Art</h2>
                <p class="text-gray-700"><span class="font-semibold">Dimensões do Canvas:</span> <span id="canvasDimensions">N/A</span></p>
                <p class="text-gray-700"><span class="font-semibold">Total de Pixels (não transparentes):</span> <span id="totalPixels">N/A</span></p>
            </div>

            <!-- Paleta de Cores Utilizadas -->
            <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                <h2 class="text-xl font-bold text-gray-800 mb-4">Paleta de Cores Utilizadas</h2>
                <div id="colorUsage" class="grid grid-cols-1 sm:grid-cols-2 gap-3 text-gray-700">
                    <p class="text-gray-500">Nenhuma cor utilizada ainda.</p>
                </div>
            </div>
        </div>

        <!-- Seção de Visualização dos Canvas -->
        <div class="relative flex flex-col space-y-6">
            <!-- Imagem Original -->
            <div class="bg-white p-4 rounded-lg shadow-sm">
                <h2 class="text-xl font-bold text-gray-800 mb-2">Imagem Original</h2>
                <canvas id="originalCanvas" class="w-full h-auto"></canvas>
            </div>

            <!-- Pixel Art Gerada -->
            <div class="bg-white p-4 rounded-lg shadow-sm">
                <h2 class="text-xl font-bold text-gray-800 mb-2">Pixel Art</h2>
                <canvas id="pixelArtCanvas" class="w-full h-auto"></canvas>
            </div>
        </div>
        <div id="colorTooltip" class="hidden"></div>
    </div>

    <script>
        // Obtenção de referências aos elementos HTML
        const imageUpload = document.getElementById('imageUpload');
        const pixelSizeInput = document.getElementById('pixelSize');
        const pixelSizeValueSpan = document.getElementById('pixelSizeValue');
        const convertBtn = document.getElementById('convertBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const originalCanvas = document.getElementById('originalCanvas');
        const pixelArtCanvas = document.getElementById('pixelArtCanvas');
        const canvasDimensionsSpan = document.getElementById('canvasDimensions');
        const totalPixelsSpan = document.getElementById('totalPixels');
        const colorUsageDiv = document.getElementById('colorUsage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const colorTooltip = document.getElementById('colorTooltip');

        // Contextos 2D para desenhar nos canvas
        const originalCtx = originalCanvas.getContext('2d');
        const pixelArtCtx = pixelArtCanvas.getContext('2d');

        let uploadedImage = null; // Variável para armazenar a imagem carregada
        let lastPixelArtData = null; // Variável para armazenar os dados do canvas da pixel art

        // Paleta de cores predefinida com nomes e valores RGB
        const colorPalette = [
            {
                name: "Black",
                rgb: [0, 0, 0]
            }, {
                name: "Dark Gray",
                rgb: [60, 60, 60]
            }, {
                name: "Gray",
                rgb: [120, 120, 120]
            }, {
                name: "Light Gray",
                rgb: [210, 210, 210]
            }, {
                name: "White",
                rgb: [255, 255, 255]
            }, {
                name: "Deep Red",
                rgb: [96, 0, 24]
            }, {
                name: "Red",
                rgb: [237, 28, 36]
            }, {
                name: "Orange",
                rgb: [255, 127, 39]
            }, {
                name: "Gold",
                rgb: [246, 170, 9]
            }, {
                name: "Yellow",
                rgb: [249, 221, 59]
            }, {
                name: "Light Yellow",
                rgb: [255, 250, 188]
            }, {
                name: "Dark Green",
                rgb: [14, 185, 104]
            }, {
                name: "Green",
                rgb: [19, 230, 123]
            }, {
                name: "Light Green",
                rgb: [135, 255, 94]
            }, {
                name: "Dark Teal",
                rgb: [12, 129, 110]
            }, {
                name: "Teal",
                rgb: [16, 174, 166]
            }, {
                name: "Light Teal",
                rgb: [19, 225, 190]
            }, {
                name: "Dark Blue",
                rgb: [40, 80, 158]
            }, {
                name: "Blue",
                rgb: [64, 147, 228]
            }, {
                name: "Cyan",
                rgb: [96, 247, 242]
            }, {
                name: "Indigo",
                rgb: [107, 80, 246]
            }, {
                name: "Light Indigo",
                rgb: [153, 177, 251]
            }, {
                name: "Dark Purple",
                rgb: [120, 12, 153]
            }, {
                name: "Purple",
                rgb: [170, 56, 185]
            }, {
                name: "Light Purple",
                rgb: [224, 159, 249]
            }, {
                name: "Dark Pink",
                rgb: [203, 0, 122]
            }, {
                name: "Pink",
                rgb: [236, 31, 128]
            }, {
                name: "Light Pink",
                rgb: [243, 141, 169]
            }, {
                name: "Dark Brown",
                rgb: [104, 70, 52]
            }, {
                name: "Brown",
                rgb: [149, 104, 42]
            }, {
                name: "Beige",
                rgb: [248, 178, 119]
            }, {
                name: "Medium Gray",
                rgb: [170, 170, 170]
            }, {
                name: "Dark Red",
                rgb: [165, 14, 30]
            }, {
                name: "Light Red",
                rgb: [250, 128, 114]
            }, {
                name: "Dark Orange",
                rgb: [228, 92, 26]
            }, {
                name: "Light Tan",
                rgb: [214, 181, 148]
            }, {
                name: "Dark Goldenrod",
                rgb: [156, 132, 49]
            }, {
                name: "Goldenrod",
                rgb: [197, 173, 49]
            }, {
                name: "Light Goldenrod",
                rgb: [232, 212, 95]
            }, {
                name: "Dark Olive",
                rgb: [74, 107, 58]
            }, {
                name: "Olive",
                rgb: [90, 148, 74]
            }, {
                name: "Light Olive",
                rgb: [132, 197, 115]
            }, {
                name: "Dark Cyan",
                rgb: [15, 121, 159]
            }, {
                name: "Light Cyan",
                rgb: [187, 250, 242]
            }, {
                name: "Light Blue",
                rgb: [125, 199, 255]
            }, {
                name: "Dark Indigo",
                rgb: [77, 49, 184]
            }, {
                name: "Dark Slate Blue",
                rgb: [74, 66, 132]
            }, {
                name: "Slate Blue",
                rgb: [122, 113, 196]
            }, {
                name: "Light Slate Blue",
                rgb: [181, 174, 241]
            }, {
                name: "Light Brown",
                rgb: [219, 164, 99]
            }, {
                name: "Dark Beige",
                rgb: [209, 128, 81]
            }, {
                name: "Light Beige",
                rgb: [255, 197, 165]
            }, {
                name: "Dark Peach",
                rgb: [155, 82, 73]
            }, {
                name: "Peach",
                rgb: [209, 128, 120]
            }, {
                name: "Light Peach",
                rgb: [250, 182, 164]
            }, {
                name: "Dark Tan",
                rgb: [123, 99, 82]
            }, {
                name: "Tan",
                rgb: [156, 132, 107]
            }, {
                name: "Dark Slate",
                rgb: [51, 57, 65]
            }, {
                name: "Slate",
                rgb: [109, 117, 141]
            }, {
                name: "Light Slate",
                rgb: [179, 185, 209]
            }, {
                name: "Dark Stone",
                rgb: [109, 100, 63]
            }, {
                name: "Stone",
                rgb: [148, 140, 107]
            }, {
                name: "Light Stone",
                rgb: [205, 197, 158]
            }];

        /**
         * Calcula a distância euclidiana entre duas cores RGB.
         * Usada para encontrar a cor mais próxima na paleta.
         * @param {number[]} rgb1 - Array RGB da primeira cor [r, g, b].
         * @param {number[]} rgb2 - Array RGB da segunda cor [r, g, b].
         * @returns {number} A distância entre as duas cores.
         */
        function colorDistance(rgb1, rgb2) {
            return Math.sqrt(
                Math.pow(rgb1[0] - rgb2[0], 2) +
                Math.pow(rgb1[1] - rgb2[1], 2) +
                Math.pow(rgb1[2] - rgb2[2], 2)
            );
        }

        /**
         * Encontra a cor mais próxima na paleta predefinida para uma dada cor RGB.
         * @param {number[]} pixelRgb - Array RGB da cor do pixel [r, g, b].
         * @returns {object} O objeto da cor da paleta mais próxima (com nome e rgb).
         */
        function findClosestColor(pixelRgb) {
            let closestColor = null;
            let minDistance = Infinity;

            for (const paletteColor of colorPalette) {
                const dist = colorDistance(pixelRgb, paletteColor.rgb);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestColor = paletteColor;
                }
            }
            return closestColor;
        }

        // Event listener para o carregamento da imagem
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage = img;
                        // Define as dimensões do canvas original para corresponder à imagem
                        originalCanvas.width = img.width;
                        originalCanvas.height = img.height;
                        originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
                        originalCtx.drawImage(img, 0, 0); // Desenha a imagem no canvas original
                        downloadBtn.disabled = true; // Desabilita o download até a conversão
                        // Limpa a pixel art anterior e as estatísticas
                        pixelArtCtx.clearRect(0, 0, pixelArtCanvas.width, pixelArtCanvas.height);
                        canvasDimensionsSpan.textContent = 'N/A';
                        totalPixelsSpan.textContent = 'N/A';
                        colorUsageDiv.innerHTML = '<p class="text-gray-500">Nenhuma cor utilizada ainda.</p>';
                        lastPixelArtData = null; // Limpa os dados da última pixel art
                    };
                    img.src = e.target.result; // Define a fonte da imagem como o resultado da leitura
                };
                reader.readAsDataURL(file); // Lê o arquivo como uma URL de dados
            }
        });

        // Atualiza o valor exibido do tamanho do pixel ao mover o slider
        pixelSizeInput.addEventListener('input', () => {
            pixelSizeValueSpan.textContent = pixelSizeInput.value;
        });

        // Event listener para o botão de conversão
        convertBtn.addEventListener('click', () => {
            if (!uploadedImage) {
                alert('Por favor, carregue uma imagem primeiro.');
                return;
            }

            loadingIndicator.classList.remove('hidden');
            convertBtn.disabled = true;
            downloadBtn.disabled = true;

            setTimeout(() => {
                const pixelSize = parseInt(pixelSizeInput.value);

                // Calcular as novas dimensões da imagem reduzida
                // Dividimos a largura e altura originais pelo tamanho do pixel.
                // Usamos Math.floor para garantir números inteiros.
                const newWidth = Math.floor(uploadedImage.width / pixelSize);
                const newHeight = Math.floor(uploadedImage.height / pixelSize);

                // Definir as dimensões do canvas de pixel art para as novas dimensões reduzidas
                pixelArtCanvas.width = newWidth;
                pixelArtCanvas.height = newHeight;

                // Definir o estilo CSS para o canvas de pixel art,
                // para que ele preencha o espaço de exibição (mantendo a proporção pixelada)
                pixelArtCanvas.style.width = '100%';
                pixelArtCanvas.style.height = 'auto'; // Garante que a proporção é mantida

                // Obtém os dados de pixel da imagem original
                const originalImageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                const data = originalImageData.data;

                const colorCounts = {};
                let nonTransparentPixels = 0;

                colorPalette.forEach(color => {
                    colorCounts[color.name] = 0;
                });

                // Limpa o canvas de pixel art para desenhar a nova versão
                pixelArtCtx.clearRect(0, 0, pixelArtCanvas.width, pixelArtCanvas.height);

                // Itera sobre os pixels da imagem REDUZIDA
                // Agora, desenhamos apenas UM pixel por cada "bloco" da imagem original,
                // usando a cor do pixel superior esquerdo desse bloco (Vizinho Mais Próximo).
                for (let y = 0; y < newHeight; y++) { // Itera pela nova altura
                    for (let x = 0; x < newWidth; x++) { // Itera pela nova largura
                        // Mapeia de volta para a posição correspondente na imagem original
                        const originalX = x * pixelSize;
                        const originalY = y * pixelSize;

                        // Pega a cor do pixel superior esquerdo do bloco na imagem original
                        const index = (originalY * originalCanvas.width + originalX) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3];

                        if (a < 50) {
                            pixelArtCtx.fillStyle = 'rgba(0,0,0,0)';
                        } else {
                            const closestColor = findClosestColor([r, g, b]);
                            pixelArtCtx.fillStyle = `rgb(${closestColor.rgb[0]},${closestColor.rgb[1]},${closestColor.rgb[2]})`;
                            colorCounts[closestColor.name]++;
                            nonTransparentPixels++;
                        }
                        
                        // Desenha APENAS UM pixel (1x1) no canvas de pixel art nas novas coordenadas
                        pixelArtCtx.fillRect(x, y, 1, 1);
                    }
                }

                // Armazena os dados do canvas para uso no hover
                lastPixelArtData = pixelArtCtx.getImageData(0, 0, pixelArtCanvas.width, pixelArtCanvas.height);

                // Atualiza as estatísticas exibidas na interface
                canvasDimensionsSpan.textContent = `${pixelArtCanvas.width} x ${pixelArtCanvas.height} pixels`;
                totalPixelsSpan.textContent = nonTransparentPixels;

                // Atualiza a exibição da paleta de cores utilizadas
                colorUsageDiv.innerHTML = '';
                let hasUsedColors = false;
                for (const colorName in colorCounts) {
                    if (colorCounts[colorName] > 0) {
                        hasUsedColors = true;
                        const color = colorPalette.find(c => c.name === colorName);
                        const colorHex = `#${color.rgb[0].toString(16).padStart(2, '0')}${color.rgb[1].toString(16).padStart(2, '0')}${color.rgb[2].toString(16).padStart(2, '0')}`;
                        colorUsageDiv.innerHTML += `
                            <div class="flex items-center space-x-2">
                                <div class="w-5 h-5 rounded-full" style="background-color: ${colorHex}; border: 1px solid #ccc;"></div>
                                <span>${colorName}: ${colorCounts[colorName]} pixels</span>
                            </div>
                        `;
                    }
                }
                if (!hasUsedColors) {
                    colorUsageDiv.innerHTML = '<p class="text-gray-500">Nenhuma cor utilizada ainda.</p>';
                }

                loadingIndicator.classList.add('hidden');
                convertBtn.disabled = false;
                downloadBtn.disabled = false;
            }, 10);
        });

        // Event listener para o botão de download
        downloadBtn.addEventListener('click', () => {
            if (pixelArtCanvas.width > 0 && pixelArtCanvas.height > 0) {
                const link = document.createElement('a');
                link.download = 'pixel-art.png';
                link.href = pixelArtCanvas.toDataURL('image/png');
                link.click();
            } else {
                alert('Não há pixel art para baixar.');
            }
        });

        // Event listener para o mouse over no canvas da pixel art para mostrar o tooltip
        pixelArtCanvas.addEventListener('mousemove', (event) => {
            if (!lastPixelArtData) return; // Não faz nada se a conversão não foi feita

            const pixelSize = parseInt(pixelSizeInput.value);
            const rect = pixelArtCanvas.getBoundingClientRect();
            const scaleX = pixelArtCanvas.width / rect.width;
            const scaleY = pixelArtCanvas.height / rect.height;

            const x = Math.floor(event.offsetX * scaleX);
            const y = Math.floor(event.offsetY * scaleY);

            // Obtém a cor do pixel na posição do mouse no canvas de pixel art
            const pixelData = pixelArtCtx.getImageData(x, y, 1, 1).data;
            const r = pixelData[0];
            const g = pixelData[1];
            const b = pixelData[2];
            const a = pixelData[3];

            // Apenas mostra o tooltip se o pixel não for transparente
            if (a > 0) {
                const closestColor = findClosestColor([r, g, b]);
                colorTooltip.textContent = closestColor.name;
                colorTooltip.style.left = `${event.pageX}px`;
                colorTooltip.style.top = `${event.pageY}px`;
                colorTooltip.classList.remove('hidden');
            } else {
                colorTooltip.classList.add('hidden');
            }
        });

        // Event listener para esconder o tooltip quando o mouse sai do canvas
        pixelArtCanvas.addEventListener('mouseout', () => {
            colorTooltip.classList.add('hidden');
        });

        /**
         * Função de alerta personalizada para substituir window.alert().
         * Cria um modal simples na tela.
         * @param {string} message - A mensagem a ser exibida no alerta.
         */
        function alert(message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50';
            alertDiv.innerHTML = `
                <div class="bg-white p-8 rounded-lg shadow-xl max-w-sm w-full text-center">
                    <p class="text-lg font-semibold text-gray-800 mb-6">${message}</p>
                    <button id="closeAlert" class="bg-indigo-600 text-white font-semibold py-2 px-5 rounded-lg hover:bg-indigo-700 transition duration-300">
                        OK
                    </button>
                </div>
            `;
            document.body.appendChild(alertDiv);

            document.getElementById('closeAlert').addEventListener('click', () => {
                document.body.removeChild(alertDiv);
            });
        }
    </script>
</body>
</html>
